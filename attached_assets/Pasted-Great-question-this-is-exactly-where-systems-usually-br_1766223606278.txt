Great question ‚Äî this is exactly where systems usually break, so let‚Äôs be very precise.

Short answer first, then the real design.

‚∏ª

SHORT ANSWER (EXECUTIVE)

Yes ‚Äî one admin action resolves the challenge once,
but payouts happen in controlled batches, not one giant transaction.

Admin resolves once.
System pays many, safely.

‚∏ª

Now let‚Äôs do this properly.

‚∏ª

THE CORE IDEA (VERY IMPORTANT)

A challenge with 10,000 users is NOT 10,000 separate resolutions.

It is:

1 resolution decision + N payout executions

You must separate:
 ‚Ä¢ Outcome decision (human, once)
 ‚Ä¢ Fund distribution (system, batched)

‚∏ª

STEP-BY-STEP: HOW MASS RESOLUTION WORKS

STEP 1 ‚Äî ADMIN RESOLVES ONCE (SINGLE SOURCE OF TRUTH)

Admin action:

Resolve Challenge ‚Üí YES wins

What happens immediately:
 ‚Ä¢ Challenge status:

pending_admin ‚Üí completed


 ‚Ä¢ Winning side recorded:

result = YES


 ‚Ä¢ Challenge is immutably closed
 ‚Ä¢ No funds move yet

This is instant, regardless of user count.

‚∏ª

STEP 2 ‚Äî SYSTEM CREATES A PAYOUT JOB (CRITICAL)

Instead of paying users inline, the system does this:

Create payout_job {
  challenge_id
  winning_side
  total_pool
  platform_fee
  status: queued
}

This job is handed to a background worker.

Why?
 ‚Ä¢ 10,000 balance updates must NOT block admin UI
 ‚Ä¢ You need retries, logging, safety

‚∏ª

STEP 3 ‚Äî USERS ARE GROUPED AUTOMATICALLY

Your system already has:
 ‚Ä¢ YES users
 ‚Ä¢ NO users
 ‚Ä¢ Stakes per user
 ‚Ä¢ Pairing records (or pooled stakes)

Now you group winners:

Two common payout models (you already lean toward #2):

OPTION A ‚Äî PAIRED PAYOUTS (current FCFS)
 ‚Ä¢ Each YES matched with a NO
 ‚Ä¢ Winner takes opponent‚Äôs stake

This scales fine, but more DB writes.

‚∏ª

OPTION B ‚Äî POOL PAYOUT (RECOMMENDED FOR LARGE PUBLIC CHALLENGES)

For admin-created public challenges, you SHOULD switch to pool-based payout.

Pool math:

total_pool = sum(all stakes)
platform_fee = X%
winner_pool = total_pool - fee

Each winner gets:

(user_stake / total_winning_stake) * winner_pool

This is:
 ‚Ä¢ Fair
 ‚Ä¢ Scales infinitely
 ‚Ä¢ Easy to audit

üëâ This is how Polymarket works internally.

‚∏ª

STEP 4 ‚Äî BATCHED PAYOUT EXECUTION (THE SECRET SAUCE)

Instead of 10,000 writes at once:

Process payouts in batches of 100‚Äì500 users

Each batch:
 ‚Ä¢ Database transaction
 ‚Ä¢ Wallet credit
 ‚Ä¢ Ledger entry
 ‚Ä¢ Notification queued

If batch fails:
 ‚Ä¢ Retry only that batch
 ‚Ä¢ No global failure

‚∏ª

STEP 5 ‚Äî USER EXPERIENCE (VERY IMPORTANT)

Immediately after admin resolves:

All users see:

‚úÖ Challenge resolved
YES wins
Payouts processing‚Ä¶

When their batch completes:

They get:

üéâ You won ‚Ç¶4,320
Funds added to wallet

This avoids:
 ‚Ä¢ ‚ÄúWhere‚Äôs my money??‚Äù
 ‚Ä¢ Support tickets
 ‚Ä¢ Panic

‚∏ª

WHY YOU MUST NOT PAY INLINE (NEVER DO THIS)

‚ùå Paying all users inside the admin click:
 ‚Ä¢ DB timeout risk
 ‚Ä¢ Partial payouts
 ‚Ä¢ Impossible rollback
 ‚Ä¢ Admin UI freezes
 ‚Ä¢ Financial nightmares

Background jobs are non-negotiable.

‚∏ª

DATA STRUCTURE YOU NEED (MINIMAL)

Add:

payout_jobs
- id
- challenge_id
- total_winners
- processed_winners
- status (queued, running, completed, failed)
- created_at

And:

payout_entries
- job_id
- user_id
- amount
- status

This gives:
 ‚Ä¢ Audit trail
 ‚Ä¢ Retry safety
 ‚Ä¢ Transparency

‚∏ª

PERFORMANCE REALITY CHECK

10,000 users is not big if you do this right.

Even with:
 ‚Ä¢ 500 users per batch
 ‚Ä¢ 200ms per batch

Total time ‚âà 4‚Äì5 seconds in background
Users won‚Äôt notice.

‚∏ª

WHAT THE ADMIN SEES (IMPORTANT)

Admin UI after clicking resolve:

Challenge resolved ‚úÖ
Payouts in progress (0 / 10,000)

Then:

Payouts completed ‚úÖ

Admin never waits.

‚∏ª

WHY THIS DESIGN IS FUTURE-PROOF

This same system supports:
 ‚Ä¢ 100 users
 ‚Ä¢ 10,000 users
 ‚Ä¢ 1 million users

No redesign later.

‚∏ª

FINAL ONE-LINE ANSWER (FOR YOUR TEAM)

Admin resolves the challenge once; the system distributes payouts asynchronously in batches using a payout job queue.

‚∏ª

If you want, next we can:
 1. Decide paired vs pool payout per challenge type
 2. Design the exact payout math
 3. Define failure & retry rules
 4. Write pseudo-code for the payout worker

Tell me the number.